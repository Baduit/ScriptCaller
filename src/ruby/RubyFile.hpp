#pragma once

#include <string>
#include <vector>
#include <random>
#include <fstream>
#include <future>
#include <thread>
#include <cstdlib>
#include <memory>

#include "../Indent.hpp"
#include "../RandGen.hpp"
#include "../communications/Communicator.hpp"

namespace ScriptCaller
{


using ClassDescription = std::string;
using FunctionDescription = std::string;
using FunctionList = std::vector<FunctionDescription>;
using ClassList = std::vector<ClassDescription>;

class RubyFile
{
	public:
		RubyFile() = default;
		RubyFile(std::string fileName, const FunctionList& fList, const ClassList& cList) :
			requiredFileName(fileName), functions(fList), classes(cList)
			{}
		
		~RubyFile() {}

		void	init(std::string fileName, const FunctionList& fList, const ClassList& cList)
		{
			requiredFileName = fileName;
			functions = fList;
			classes = cList;
		}

		void	createFile()
		{
			std::ofstream outputFile = openFile();
			setNamedPipeNames();

			writeHeader(outputFile);
			writeUtilitaryFunctions(outputFile);
			

			writeActionHandling(outputFile);
			writeActionDividing(outputFile);
		}


		const std::string& getOutputFileName() const { return _outputFileName; }
		const std::string& getNamedPipeInputName() const { return _namedPipeInputName; }
		const std::string& getNamedPipeOutputName() const { return _namedPipeOutputName; }

	private:
		std::ofstream		openFile()
		{
			_outputFileName = "/tmp/fifo_" + std::to_string(_randGen()) + ".rb";
			return std::ofstream(_outputFileName);
		}

		void				setNamedPipeNames()
		{
			_namedPipeInputName = "/tmp/fifo_input" + std::to_string(_randGen());
			_namedPipeOutputName = "/tmp/fifo_output" + std::to_string(_randGen());
		}

		void				writeUtilitaryFunctions(std::ostream& os)
		{
			writeImports(os);
			writeObjectToSerialisable(os);
			writeCommunication(os);
		}

		void				writeActionHandling(std::ostream& os)
		{
			writeFunctionHandling(os);
			writeStaticMethodHandling(os);
			writeMethodHandling(os);
			writeCreateObjectHandling(os);
			writeGetObjetHandling(os);
			writeGetValueHandling(os);
			writeStoreValueHandling(os);
		}

		void				writeActionDividing(std::ostream& os)
		{
			os << "taskOver = false" << std::endl;
			os << "createdVariables = {}" << std::endl;
			os << "while true do" << std::endl;
			os << _ident(1) << "orderString = input.gets" << std::endl;
			os << _ident(1) << "orderString = orderString.chop" << std::endl;
			os << _ident(1) << "if orderString == '__STOP_SCRIPT__'" << std::endl;
			os << _ident(2) << "exit(0)" << std::endl;
			os << _ident(1) << "end" << std::endl;
			os << _ident(1) << "order = JSON.parse(orderString, object_class: OpenStruct)" << std::endl;
			os << _ident(1) << "answer = 'actionType incorrect'.to_json" << std::endl;
			os << _ident(1) << "if order.actionType == '"<< ActionType::callFunction << "'" << std::endl;
			os << _ident(2) << "answer = bigSwitch(order)" << std::endl;
			os << _ident(1) << "elsif order.actionType == '"<< ActionType::callStaticMethod << "'" << std::endl;
			os << _ident(2) << "answer = callStaticMethod(order)" << std::endl;
			os << _ident(1) << "elsif order.actionType == '"<< ActionType::callObjectMethod << "'" << std::endl;
			os << _ident(2) << "answer = callMethod(order, createdVariables)" << std::endl;
			os << _ident(1) << "elsif order.actionType == '"<< ActionType::createObject << "'" << std::endl;
			os << _ident(2) << "answer = createObject(order, createdVariables)" << std::endl;
			os << _ident(1) << "elsif order.actionType == '"<< ActionType::storeValue << "'" << std::endl;
			os << _ident(2) << "answer = storeValue(order, createdVariables)" << std::endl;
			os << _ident(1) << "elsif order.actionType == '"<< ActionType::getObject << "'" << std::endl;
			os << _ident(2) << "answer = getObject(order, createdVariables)" << std::endl;
			os << _ident(1) << "elsif order.actionType == '"<< ActionType::getValue << "'" << std::endl;
			os << _ident(2) << "answer = getValue(order, createdVariables)" << std::endl;
			os << _ident(1) << "end" << std::endl;
			os << _ident(1) << "output.puts(answer.to_json) " << std::endl;
			os << _ident(1) << "output.flush " << std::endl;
			os << "end" << std::endl;
		}

		void				writeHeader(std::ostream& os)
		{
			os << "# File generated by ScriptCaller" << std::endl;
			os << "# https://github.com/Baduit/ScriptCaller" << std::endl;
		}

		void				writeImports(std::ostream& os)
		{
			os << "require '" << requiredFileName << "'" << std::endl << std::endl;
			os << "require 'json'" << std::endl << std::endl;
		}

		void				writeObjectToSerialisable(std::ostream& os)
		{
			os << "def objectToHash(obj)" << std::endl;
			os << _ident(1) << "hash = {}" << std::endl;
			os << _ident(1) << "obj.instance_variables.each {|var| hash[var.to_s.delete(\"@\")] = obj.instance_variable_get(var.to_s) }" << std::endl;
			os << _ident(1) << "return hash" << std::endl;
			os << "end" << std::endl;
		}

		void				writeCommunication(std::ostream& os)
		{
			os << "input = open('" << _namedPipeInputName << "', \"r\")" << std::endl << std::endl;
			os << "output = open('" << _namedPipeOutputName << "', \"w\")" << std::endl << std::endl;
		}

		void				writeFunctionHandling(std::ostream& os)
		{
			os << "def bigSwitch(order)" << std::endl;
			for (const auto& f: functions)
			{
				os << _ident(1) << "if order.functionName == \"" << f << "\""<< std::endl;
				os << _ident(2) << "return " << f << " *(order.args)" << std::endl;
				os << _ident(1) << "end" << std::endl;
			}
			os << _ident(1) << "return 'Error: function unknown'" << std::endl;
			os << "end" << std::endl << std::endl;
		}

		void				writeStaticMethodHandling(std::ostream& os)
		{
			os << "def callStaticMethod(order)" << std::endl;
			for (const auto& c: classes)
			{
				os << _ident(1) << "if order.className == \"" << c << "\""<< std::endl;
				os
					<< _ident(2)<< "return "
					<< c << ".method(order.methodName).call *(order.args)" << std::endl;
				os << _ident(1) << "end" << std::endl;
			}
			os << _ident(1) << "return 'Error: classes unknown'" << std::endl;
			os << "end" << std::endl << std::endl;
		}

		void				writeMethodHandling(std::ostream& os)
		{
			os << "def callMethod(order, createdVariables)" << std::endl;
			os << _ident(1) << "return createdVariables[order.objectName].method(order.methodName).call *(order.args)" << std::endl;
			os << "end" << std::endl << std::endl;
		}

		void				writeCreateObjectHandling(std::ostream& os)
		{
			os << "def createObject(order, createdVariables)" << std::endl;
			for (const auto& c: classes)
			{
				os << _ident(1) << "if order.className == \"" << c << "\""<< std::endl;
				os
					<< _ident(2)<< "createdVariables[order.objectName] = "
					<< c << ".new(*(order.args))" << std::endl;
				os << _ident(1) << "return objectToHash(createdVariables[order.objectName])" << std::endl;
				os << _ident(1) << "end" << std::endl;
			}
			os << _ident(1) << "return 'Error: classes unknown'" << std::endl;
			os << "end" << std::endl << std::endl;
		}

		void				writeGetObjetHandling(std::ostream& os)
		{
			os << "def getObject(order, createdVariables)" << std::endl;
			os << _ident(1) << "return objectToHash(createdVariables[order.variableName])" << std::endl;
			os << "end" << std::endl << std::endl;
		}

		void				writeGetValueHandling(std::ostream& os)
		{
			os << "def getValue(order, createdVariables)" << std::endl;
			os << _ident(1) << "return createdVariables[order.variableName]" << std::endl;
			os << "end" << std::endl << std::endl;
		}

		void				writeStoreValueHandling(std::ostream& os)
		{
			os << "def storeValue(order, createdVariables)" << std::endl;
			os << _ident(1) << "createdVariables[order.valueName] = order.value" << std::endl;
			os << _ident(1) << "return createdVariables[order.valueName]" << std::endl;
			os << "end" << std::endl << std::endl;
		}

	public:
		std::string		requiredFileName;
		FunctionList	functions;
		ClassList		classes;

	private:
		std::string						_outputFileName;
		std::string						_namedPipeInputName; // cpp to script, script read here
		std::string						_namedPipeOutputName; // script to cpp, script write here

		RandGen							_randGen;
		IndentFactory					_ident;
};

}