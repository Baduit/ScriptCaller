#pragma once

#include <string>
#include <vector>
#include <random>
#include <fstream>
#include <future>
#include <thread>
#include <cstdlib>
#include <memory>

#include "json.hpp"

// for convenience
using json = nlohmann::json;
using Strings = std::vector<std::string>;

#include "RandGen.hpp"
#include "../communications/Communicator.hpp"

namespace ScriptCaller
{


using ClassDescription = std::string;
using FunctionDescription = std::string;
using FunctionList = std::vector<FunctionDescription>;
using ClassList = std::vector<ClassDescription>;

class RubyFile
{
	public:
		RubyFile() = default;
		RubyFile(std::string fileName, const FunctionList& fList, const ClassList& cList) :
			requiredFileName(fileName), functions(fList), classes(cList)
			{}
		
		~RubyFile() {}

		void	init(std::string fileName, const FunctionList& fList, const ClassList& cList)
		{
			requiredFileName = fileName;
			functions = fList;
			classes = cList;
		}

		void	createFile()
		{
			// create the file with a header
			_outputFileName = "/tmp/fifo_" + std::to_string(_randGen()) + ".rb";
			std::ofstream outputFile(_outputFileName);
			outputFile << "# File generated by ScriptCaller" << std::endl;
			outputFile << "# https://github.com/Baduit/ScriptCaller" << std::endl;

			// add the require statement
			outputFile << "require '" << requiredFileName << "'" << std::endl << std::endl;
			outputFile << "require 'json'" << std::endl << std::endl;

			// function object to hash
			outputFile << "def objectToHash(obj)" << std::endl;
			outputFile << "\t" << "hash = {}" << std::endl;
			outputFile << "\t" << "obj.instance_variables.each {|var| hash[var.to_s.delete(\"@\")] = obj.instance_variable_get(var.to_s) }" << std::endl;
			outputFile << "\t" << "return hash" << std::endl;
			outputFile << "end" << std::endl;



			// create both named pipe
			_namedPipeInputName = "/tmp/fifo_input" + std::to_string(_randGen());
			_namedPipeOutputName = "/tmp/fifo_output" + std::to_string(_randGen());

			outputFile << "input = open('" << _namedPipeInputName << "', \"r\")" << std::endl << std::endl;
			outputFile << "output = open('" << _namedPipeOutputName << "', \"w\")" << std::endl << std::endl;

			// create the function which call the good function
			outputFile << "def bigSwitch(order)" << std::endl;
			for (const auto& f: functions)
			{
				outputFile << "\t" << "if order.functionName == \"" << f << "\""<< std::endl;
				outputFile << "\t\t"<< "return " << f << " *(order.args)" << std::endl;
				outputFile << "\t" << "end" << std::endl;
			}
			outputFile << "\t" << "return 'Error: function unknown'" << std::endl;
			outputFile << "end" << std::endl << std::endl;

			// function to call a static method
			outputFile << "def callStaticMethod(order)" << std::endl;
			for (const auto& c: classes)
			{
				outputFile << "\t" << "if order.className == \"" << c << "\""<< std::endl;
				outputFile
					<< "\t\t"<< "return "
					<< c << ".method(order.methodName).call *(order.args)" << std::endl;
				outputFile << "\t" << "end" << std::endl;
			}
			outputFile << "\t" << "return 'Error: classes unknown'" << std::endl;
			outputFile << "end" << std::endl << std::endl;

			// function to store a value
			outputFile << "def storeValue(order, createdVariables)" << std::endl;
			outputFile << "\t" << "createdVariables[order.valueName] = order.value" << std::endl;
			outputFile << "\t" << "return createdVariables[order.valueName]" << std::endl;
			outputFile << "end" << std::endl << std::endl;
			
			// function to create an object
			outputFile << "def createObject(order, createdVariables)" << std::endl;
			for (const auto& c: classes)
			{
				outputFile << "\t" << "if order.className == \"" << c << "\""<< std::endl;
				outputFile
					<< "\t\t"<< "createdVariables[order.objectName] = "
					<< c << ".new(*(order.args))" << std::endl;
				outputFile << "\t" << "return objectToHash(createdVariables[order.objectName])" << std::endl;
				outputFile << "\t" << "end" << std::endl;
			}
			outputFile << "\t" << "return 'Error: classes unknown'" << std::endl;
			outputFile << "end" << std::endl << std::endl;

			// function to get an object
			outputFile << "def getObject(order, createdVariables)" << std::endl;
			outputFile << "\t" << "return objectToHash(createdVariables[order.variableName])" << std::endl;
			outputFile << "end" << std::endl << std::endl;

			// function to get an object
			outputFile << "def getValue(order, createdVariables)" << std::endl;
			outputFile << "\t" << "return createdVariables[order.variableName]" << std::endl;
			outputFile << "end" << std::endl << std::endl;

			// function to call a method
			outputFile << "def callMethod(order, createdVariables)" << std::endl;
			outputFile << "\t" << "return createdVariables[order.objectName].method(order.methodName).call *(order.args)" << std::endl;
			outputFile << "end" << std::endl << std::endl;

			// create the part using the named pipe created earlier
			outputFile << "taskOver = false" << std::endl;
			outputFile << "createdVariables = {}" << std::endl;
			outputFile << "while true do" << std::endl;
			outputFile << "\t" << "orderString = input.gets" << std::endl;
			outputFile << "\t" << "orderString = orderString.chop" << std::endl;
			outputFile << "\t" << "if orderString == '__STOP_SCRIPT__'" << std::endl;
			outputFile << "\t\t" << "exit(0)" << std::endl;
			outputFile << "\t" << "end" << std::endl;
			outputFile << "\t" << "order = JSON.parse(orderString, object_class: OpenStruct)" << std::endl;
			outputFile << "\t" << "answer = 'actionType incorrect'.to_json" << std::endl;
			outputFile << "\t" << "if order.actionType == '"<< ActionType::callFunction << "'" << std::endl;
			outputFile << "\t\t" << "answer = bigSwitch(order)" << std::endl;
			outputFile << "\t" << "elsif order.actionType == '"<< ActionType::callStaticMethod << "'" << std::endl;
			outputFile << "\t\t" << "answer = callStaticMethod(order)" << std::endl;
			outputFile << "\t" << "elsif order.actionType == '"<< ActionType::callObjectMethod << "'" << std::endl;
			outputFile << "\t\t" << "answer = callMethod(order, createdVariables)" << std::endl;
			outputFile << "\t" << "elsif order.actionType == '"<< ActionType::createObject << "'" << std::endl;
			outputFile << "\t\t" << "answer = createObject(order, createdVariables)" << std::endl;
			outputFile << "\t" << "elsif order.actionType == '"<< ActionType::storeValue << "'" << std::endl;
			outputFile << "\t\t" << "answer = storeValue(order, createdVariables)" << std::endl;
			outputFile << "\t" << "elsif order.actionType == '"<< ActionType::getObject << "'" << std::endl;
			outputFile << "\t\t" << "answer = getObject(order, createdVariables)" << std::endl;
			outputFile << "\t" << "elsif order.actionType == '"<< ActionType::getValue << "'" << std::endl;
			outputFile << "\t\t" << "answer = getValue(order, createdVariables)" << std::endl;
			outputFile << "\t" << "end" << std::endl;
			outputFile << "\t" << "output.puts(answer.to_json) " << std::endl;
			outputFile << "\t" << "output.flush " << std::endl;
			outputFile << "end" << std::endl;
		}


		const std::string& getOutputFileName() const { return _outputFileName; }
		const std::string& getNamedPipeInputName() const { return _namedPipeInputName; }
		const std::string& getNamedPipeOutputName() const { return _namedPipeOutputName; }

	public:
		std::string		requiredFileName;
		FunctionList	functions;
		ClassList		classes;

	private:
		std::string						_outputFileName;
		std::string						_namedPipeInputName; // cpp to script, script read here
		std::string						_namedPipeOutputName; // script to cpp, script write here

		RandGen							_randGen;
};

}